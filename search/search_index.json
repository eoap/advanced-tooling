{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Advanced Tooling in Earth Observation Application Packaging with CWL","text":""},{"location":"in-cluster-build/","title":"In-Cluster Container Image Build using Kaniko","text":"<p>This guide describes the in-cluster container image build process using Kaniko and Skaffold, configured through a custom project.toml and Taskfile.yaml. It supports building container images for CWL CommandLineTools defined in a modular CWL workflow.</p>"},{"location":"in-cluster-build/#project-structure","title":"Project Structure","text":"<p>The root project contains:</p> <ul> <li> <p><code>project.toml</code>: Declarative metadata about tools, workflows, build engine, test parameters.</p> </li> <li> <p><code>command-line-tools/</code>: One subdirectory per tool, each with a Dockerfile and tool-specific code.</p> </li> <li> <p><code>cwl-workflow/</code>: CWL workflows referencing tools via path anchors.</p> </li> </ul>"},{"location":"in-cluster-build/#build-configuration","title":"Build Configuration","text":"<p><code>project.toml</code> key sections</p> <pre><code>[build]\nengine = \"cluster\"\n\n[build.cluster]\nnamespace = \"eoap-advanced-tooling\"\nserviceAccount = \"kaniko-sa\"\nregistry = \"ghcr.io/eoap\"\nsecret = \"kaniko-secret\"\n</code></pre> <p>The above sets the build engine to cluster, targeting in-cluster Kaniko builds in namespace <code>eoap-advanced-tooling</code> using the given service account and secret for pushing to the container registry.</p> <p>Each tool under [tools.] defines: <ul> <li> <p><code>context</code>: Path to Docker build context.</p> </li> <li> <p><code>path</code>: CWL document reference to update post-build.</p> </li> </ul>"},{"location":"in-cluster-build/#build-process-overview","title":"Build Process Overview","text":"<ol> <li>Prepare Skaffold Config (Task: prepare-kaniko)</li> </ol> <p>This generates a dynamic skaffold-auto.yaml by:</p> <ul> <li> <p>Extracting all tool context directories and image names.</p> </li> <li> <p>Inserting them into .build.artifacts using yq.</p> </li> <li> <p>Mounting the kaniko-secret to authenticate with ghcr.io.</p> </li> </ul> <p>This enables Skaffold to understand how to build each tool's container image with Kaniko.</p> <ol> <li>Execute In-Cluster Build (Task: build-kaniko)</li> </ol> <p>Runs:</p> <p>bash <code>skaffold build -f skaffold-auto.yaml -v=error -q &gt; build.json</code></p> <p>Result:</p> <ul> <li> <p>Kaniko builds each image from the provided context.</p> </li> <li> <p>Images are pushed to the configured registry.</p> </li> <li> <p><code>build.json</code> captures the image digests (e.g., sha256: tags).</p> </li> <li> <p>CWL DockerRequirement Update (Task: update)</p> </li> </ul> <p>This task reads <code>build.json</code>, extracts each built image tag, and updates the CWL files defined in <code>project.toml</code>:</p> <p>If a tool has <code>hints.DockerRequirement</code>, it is updated.</p> <p>Otherwise, <code>requirements.DockerRequirement</code> is injected or updated.</p> <p>Effectively, this replaces all <code>dockerPull: hints</code> in CWL CommandLineTools with the freshly built and pushed image references.</p>"},{"location":"in-cluster-build/#full-build-chain","title":"Full Build Chain","text":"<p>To run the entire build:</p> <pre><code>task build\n</code></pre> <p>This executes:</p> <ul> <li>prepare-kaniko</li> <li>build-kaniko</li> <li>update</li> </ul> <p>You can also build locally for debugging (build-local) or generate TTL-based images (<code>build-ttl</code>).</p>"},{"location":"in-cluster-build/#running-tests-in-cluster","title":"Running Tests in Cluster","text":"<p>The test task uses Calrissian to run tests defined under:</p> <pre><code>[tools.&lt;tool&gt;.tests]\n\n[[workflows.tests]]\n</code></pre> <p>Each test defines inputs, execution config (RAM, CPU, service account), and output locations. The engine is automatically detected from <code>project.toml</code>.</p> <p>Example command executed:</p> <pre><code>calrissian \\\n  --stdout /calrissian/crop-green/results.json \\\n  --stderr /calrissian/crop-green/app.log \\\n  --max-ram 1G \\\n  --max-cores 1 \\\n  --outdir /calrissian/crop-green/results \\\n  --tool-logs-basepath logs \\\n  --pod-serviceaccount calrissian-sa \\\n  cwl-workflow/app-water-bodies-cloud-native.cwl#crop params.yaml\n</code></pre> <p>To run all tests:</p> <p><code>task test-all</code></p>"},{"location":"in-cluster-build/#summary","title":"Summary","text":"Step Tool Used Description Config generation <code>prepare-kaniko</code> Builds <code>skaffold-auto.yaml</code> dynamically from <code>project.toml</code>. Image build <code>skaffold</code> + Kaniko Executes in-cluster container builds and pushes to the container registry. CWL update <code>update</code> Rewrites <code>DockerRequirement</code> with SHA-based image tags in CWL documents. Execution <code>calrissian</code> Runs CWL <code>CommandLineTool</code> and <code>Workflow</code> tests inside the Kubernetes cluster."},{"location":"in-cluster-build/#notes","title":"Notes","text":"<ul> <li>Works with multi-tool CWL workflows.</li> <li>Enables SHA-pinned reproducibility via update step.</li> <li>TTL build support targets ephemeral build systems (e.g., ttl.sh).</li> </ul>"},{"location":"oci-artifacts/","title":"\ud83d\udce6 OCI Artifact Publishing for CWL Workflows with Embedded SBOMs","text":""},{"location":"oci-artifacts/#overview","title":"Overview","text":"<p>The CI step, <code>publish-oci-artifact</code>, publishes a Common Workflow Language (CWL) document as an OCI artifact to GitHub Container Registry (<code>ghcr.io</code>) and attaches Software Bill of Materials (SBOMs) for each container image referenced in the workflow.</p> <p>This makes the CWL workflow self-describing, portable, and security-aware\u2014without requiring direct access to the containers it uses at runtime.</p>"},{"location":"oci-artifacts/#why-oci-artifacts-for-cwl","title":"Why OCI Artifacts for CWL?","text":"<p>OCI artifacts are a standardized way to publish non-container objects like Helm charts, WASM modules, or in this case, CWL documents. This lets you:</p> <ul> <li>Version and tag workflows just like Docker images</li> <li>Push to and pull from OCI-compatible registries</li> <li>Attach related metadata, such as SBOMs, licenses, or provenance attestations</li> <li>Distribute CWL workflows securely and reproducibly</li> </ul>"},{"location":"oci-artifacts/#why-attach-sboms","title":"Why Attach SBOMs?","text":"<p>Most CWL workflows depend on container images declared via:</p> <pre><code>hints:\n  DockerRequirement:\n    dockerPull: ghcr.io/your-org/tool:1.2.3\n</code></pre> <p>However, CWL alone doesn\u2019t embed what is inside those containers. By generating and attaching SBOMs (via syft), we enrich the CWL artifact with security and supply chain transparency:</p> <ul> <li> <p>Security Scanning: SBOMs allow for vulnerability scans of container contents without downloading or executing the containers.</p> </li> <li> <p>Compliance Auditing: Includes details on licenses, libraries, and binaries used.</p> </li> <li> <p>Reproducibility: Makes the full dependency stack explicit.</p> </li> <li> <p>Offline Analysis: Consumers can retrieve and inspect the SBOM from the CWL OCI artifact.</p> </li> </ul>"},{"location":"oci-artifacts/#what-does-the-ci-step-do","title":"What Does the CI Step Do?","text":"<p>Install oras and syft for pushing OCI artifacts and generating SBOMs.</p> <ul> <li> <p>Login to ghcr.io using the GITHUB_TOKEN.</p> </li> <li> <p>For each CWL file:</p> </li> <li> <p>Publish the CWL as an OCI artifact:</p> </li> </ul> <pre><code>oras push ghcr.io/your-org/your-repo/your-workflow:1.2.3 \\\n  --artifact-type application/cwl \\\n  app-workflow.cwl:application/cwl\n</code></pre> <ul> <li> <p>Extract all container image references (dockerPull) from the CWL.</p> </li> <li> <p>For each image:</p> </li> <li> <p>Generate an SBOM using syft.</p> </li> <li> <p>Attach the SBOM to the CWL artifact:</p> </li> </ul> <pre><code>oras attach ghcr.io/.../workflow:1.2.3 \\\n  --artifact-type application/spdx+json \\\n  sbom.spdx.json\n</code></pre>"},{"location":"oci-artifacts/#benefits-at-a-glance","title":"Benefits at a Glance","text":"Feature Benefit OCI artifact CWL workflows are versioned, taggable, and registrable SBOM attachment Transparent container dependencies No need for image access SBOMs are stored externally, no image pull required Reproducibility &amp; auditing Enables end-to-end provenance and security introspection CWL+OCI integration Treats workflows as first-class, shareable build artifacts <p>Example Artifact Tree:</p> <pre><code>ghcr.io/org/repo/app-water-bodies-cloud-native:1.1.0\n\u251c\u2500\u2500 manifest: application/cwl\n\u251c\u2500\u2500 layer: app-water-bodies-cloud-native.cwl\n\u251c\u2500\u2500 attached:\n\u2502   \u251c\u2500\u2500 type: application/spdx+json\n\u2502   \u251c\u2500\u2500 name: ghcr.io/org/tool-a@sha256:...sbom.spdx.json\n\u2502   \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"oci-artifacts/#scanning-the-oci-artifacts-for-vulnerabilities","title":"Scanning the OCI artifacts for vulnerabilities","text":"<p>Use <code>task scan</code> to inspect the Application Package OCI artifact and scan the container vulnerabilitie:</p> <p>This prints: </p> <pre><code>\ud83d\udd0d Discovering SBOM digests for ghcr.io/eoap/advanced-tooling/app-water-body-cloud-native:0.1.0...\n\ud83d\udce5 Pulling sha256:e01b2de4387d7b20e83c13126738ab044a556497105c79b3809c388dd0d519a1 \u2192 attached-sboms/sha256:e01b2de4387d7b20e83c13126738ab044a556497105c79b3809c388dd0d519a1\n\u2713 Pulled      sboms/ghcr.io_eoap_advanced-tooling_crop_sha256_25aa81b7a9ea49ed94a8a6f070d84039d9e5071f4bc78061f52146c7d37705a8.sbom.spdx.j. 2.74/2.74 MB 100.00%     2s\n  \u2514\u2500 sha256:a6800275c9ccbbca4ea7b935f78605a1e74c5946ab668951bfd2338315161f65\n\u2713 Pulled      application/vnd.oci.image.manifest.v1+json                                                                                      860/860  B 100.00%     0s\n  \u2514\u2500 sha256:e01b2de4387d7b20e83c13126738ab044a556497105c79b3809c388dd0d519a1\nPulled [registry] ghcr.io/eoap/advanced-tooling/app-water-body-cloud-native:0.1.0@sha256:e01b2de4387d7b20e83c13126738ab044a556497105c79b3809c388dd0d519a1\nDigest: sha256:e01b2de4387d7b20e83c13126738ab044a556497105c79b3809c388dd0d519a1\n\ud83e\uddea Scanning SBOM: attached-sboms/sha256:e01b2de4387d7b20e83c13126738ab044a556497105c79b3809c388dd0d519a1/sboms/ghcr.io_eoap_advanced-tooling_crop_sha256_25aa81b7a9ea49ed94a8a6f070d84039d9e5071f4bc78061f52146c7d37705a8.sbom.spdx.json\n2025-06-20T07:48:17+02:00       INFO    Vulnerability scanning is enabled\n2025-06-20T07:48:17+02:00       INFO    Detected SBOM format    format=\"spdx-json\"\n2025-06-20T07:48:17+02:00       WARN    Ignore the OS package as no OS is detected.\n2025-06-20T07:48:17+02:00       INFO    Number of language-specific files       num=1\n2025-06-20T07:48:17+02:00       INFO    [python-pkg] Detecting vulnerabilities...\n\nPython (python-pkg)\n\nTotal: 3 (UNKNOWN: 0, LOW: 0, MEDIUM: 1, HIGH: 2, CRITICAL: 0)\n\n...\n</code></pre>"},{"location":"oci-artifacts/#related-tools","title":"Related Tools","text":"<p>oras \u2013 OCI Registry As Storage CLI</p> <p>syft \u2013 SBOM generation CLI</p> <p>OCI Artifact Spec \u2013 open standard for publishing non-container objects</p>"}]}